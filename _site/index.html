<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta content="en-au" http-equiv="Content-Language" />
		<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
		<link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Blog Feed" />
		<link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Blog Feed" />

		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
		<title>SiteName</title>
		<link rel="stylesheet" type="text/css" href="/css/style.css" />
		<link rel="shortcut icon" href="/img/favicon.ico" />
	</head>
	<body>
		<div id="container">
			<div id="side">
				<a href="/" id="home" title="home" alt="home"><img src="/img/logo.png" alt="Site Name" /></a>
				<div id="hometext"><a href="/" >George Mauer's Blog</a></div>
				<div class="section">
					<ul>
						<li><a href="/about.html">about</a></li>
						<li><a href="/rss.xml"><img src="/img/25.png" /> feed</a></li>
					</ul>
				</div>
			</div>
			<div id="content">
				<ul class="posts">
    
		<li>
			<div class="idea">
				
					<h1><a href="/2014/08/02/be-the-javascriptiest.html">Talk Roundup - Be the Javascriptiest</a></h1>
					
					<div class="postdate">2      August, 2014
						<ul>
						
						</ul>
					</div>
					
					<h2>Be the Javascriptiest</h2>
<p>While there is some general philosophizing here, this is largely a step-by-step for building your own jquery collapsing widget. It is a writeup of my talk at <a href="http://sqlsaturday.com/324/eventhome.aspx">Sql Saturday #324 - Baton Rouge</a>. As such, it might seem lengthy and rambling. But the talk was over an hour so...</p>
<p>It all started as a joke, or rather as <a href="http://geekswithblogs.net/mikehuguet/Default.aspx">Mike Huguet</a> bugging me to submit something on javascript to which I responded with a flurry of serious submissions along with this silly, silly title. To nobody's surprise but my own, it of course got selected. I didn't know what to do with it. Oh well.</p>
<p>Fortunately I've got a lot to say. About Javascript especially.</p>
<p>But before I start, any time you want to talk javascript it's good to understand it's history as a baseline. Rather than rehashing the exact thing I said, <a href="https://www.w3.org/community/webed/wiki/A_Short_History_of_JavaScript">here's a series</a> of actually <a href="http://dailyjs.com/history-of-javascript.html">factual articles</a>. The general gist is this: <em>Brendan Eich was given ten days by Netscape to invent a browser language. He based it on Scheme. Marketing decided that it should look like Java, so it got some angle brackets.</em> The reason it is important to know this - there are parts of Javascript simply make no sense except in the historical context.</p>
<p>Another note. If you have not read this book. </p>
<p><img src="http://ecx.images-amazon.com/images/I/518QVtPWA7L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU01_.jpg" alt="Javascript the Good Parts" /> </p>
<p>Read it. It's an easy read and covers most of the things you need to know. <a href="http://it-ebooks.info/book/274/">Hey, here it is for free.</a></p>
<p>So why this presentation at all? Well, despite the title. Javascript the Good Parts is mostly about the bad parts of Javascript. It's about all the stuff that was cludged into it by marketing, or all the mistakes that were made as a result of the insanely hurried timeframe, or all the things that have just staled over the last fifteen years of non-evolution.</p>
<p>But there are good parts. In my opinion here they are:</p>
<ul>
<li>Use functions for everything</li>
<li>Boolean Type Coercion</li>
<li>JSON Notation</li>
<li>Objects as hashes</li>
<li>Hoisting</li>
<li>Dynamic function signatures</li>
</ul>
<p>Rather than 30 slides about which I will blab for an hour I decided to do that thing that new presenters are always cautioned against - I decided to live-code. I decided to live-code a real life component that demonstrates why these things are awesome.</p>
<p>We're going to make a reusable collapser widget. This is what we're going for</p>
<p><a class="jsbin-embed" href="http://jsbin.com/zatey/5/embed?output">Final desired output</a></p>
<p>Click around. Nice, huh?</p>
<p>For simplicity's sake we're going to assume jquery. We're also going to start with the html and css already written because I'll assume you can get that knowledge elsewhere (and leave a comment if you would like another article on this). I will also purposefully avoid making this a jquery plugin - although that would be natural here, there are several things I would like to do that are easier demo'ed by a plain and simple function.</p>
<h2>Desired API</h2>
<p>So first, let's consider how we need this thing to work. We need a function. That will take an element. And make it collapsible. <code>makeCollapsible</code> sounds like a good function name for this, yeah?</p>
<pre><code class="javascript">
//Pass in jQuery
makeCollapsible( $('.should-collapse').first() );
//Pass in a DOM element
makeCollapsible( document.querySelector('.should-collapse') );
//Pass in an options object that overrides defaults
makeCollapsible( '.should-collapse', { 
  collapsed: true //should the initial state be collapsed?
} );
</code></pre>
<p>Good? Great.</p>
<p>Ok, let's get coding. So to start with, since <code>makeCollapsible</code> will be reusable, we want it in its own module.</p>
<p>If you have a module system such as requirejs or browserify in place, by all means use it here, if not then you should still try to emulate it <a href="http://en.wikipedia.org/wiki/Immediately-invoked_function_expression">with an IIFE</a>. Create a stub function inside of there, export it to the global scope, select some elements and invoke it on each.</p>
<pre><code class="javascript">
(function(){

  function makeCollapsible(el) {
    
  }
  
  window.makeCollapsible = makeCollapsible;
})()

////////////////////////////////////////////

$(function(){
  
  $('.should-collapse').toArray()
  		.map(function(el){ makeCollapsible(el) })
  
})
</code></pre>
<p>That looks nice, don't it? Straightforward. Keep in mind that if you need to export anything out of an IIFE you always want to do it at the very end. Also note that I call <code>toArray</code> on the jquery elements (called a matched set) and use the js array's built-in <code>.map</code>. This is because jquery - which preceeded the builtin map function - screwed up and inverted the parameters into the callback thereby making it harder to work with the 90% use case. Its almost entirely a matter of preference.</p>
<h2>Working Basics</h2>
<p>Ok, fun. Now let's get things actually working. First let's consider the html we want to achieve. If someone later uses javascript to remove the element entirely from the page we want it to remove cleanly, that means that everything has to go inside the element. We also want the triangle button to be visible when the element is collapsed - we therefore need it to be outside the area we will actually be collapsing. So what we're aiming for is something like this</p>
<pre><code class="html">
&lt;p class=&quot;should-collapse collapsible&quot;&gt;
    &lt;button class=&quot;collapsible-collapse-handle&quot; type=button&gt;&lt;/button&gt;
    &lt;span class=&quot;collapsible-collapse-area&quot;&gt;
        Text to collapse....
    &lt;/span&gt;
&lt;/p&gt;
</code></pre>
<p>We want to wrap the element contents in a new <code>&lt;span class=collapsible-collapse-area&gt;</code> and we want to prepend a new <code>&lt;button class=collapsible-collapse-handle&gt;</code>. And that's it. Our CSS will take care of the rest.</p>
<p>Creating this is helped tremendously by the existence of the jquery functions <a href="http://api.jquery.com/wrapinner/"><code>$.fn.wrapInner</code></a> and <a href="http://api.jquery.com/prependTo/"><code>$.fn.prependTo</code></a>, and the jquery api for <a href="http://api.jquery.com/jquery/#jQuery2">creating elements</a>.</p>
<pre><code class="javascript">
function makeCollapsible(el) {
	var $el = $(el);
	$el.addClass(&#039;collapsible&#039;);

	$el.wrapInner( $(&#039;&lt;span&gt;&#039;, {&#039;class&#039;: &#039;collapsible-collapse-area&#039;}) );
	var $collapseHandle = $(&#039;&lt;button&gt;&#039;, {&#039;class&#039;: &#039;collapsible-collapse-handle&#039;});
								.prependTo($el)
}
</code></pre>
<p>For those familiar with the above methods this should be fairly straightforward. </p>
<p>An additional thing to note is the <code>var $el = $(el)</code> rewrapping toward the top. </p>
<p>First on the <code>$name</code> convention - this is my convention for anything I know to be a jquery element. Usually I don't bother with <a href="http://en.wikipedia.org/wiki/Hungarian_notation">hungarian notation</a> but since you often use more than one jquery function on a single matched set it seems to make sense in this case.</p>
<p>Next on that re-wrapping. This is dynamic function signatures at work. You can pass anything into a jQuery function! It will just work. How do they achieve this? Why a large yet cleverly written if statement of course. There's no function overloading or pattern matching in javascript but who cares? <a href="https://github.com/jquery/jquery/blob/c869a1ef8a031342e817a2c063179a787ff57239/src/core/init.js#L16">It's not all that bad</a> and javascript benefits from a lower concept count. Don't get me wrong, I appreciate pattern matching and the like, its just that it frequently ends up being a nicer syntax for if statements. And there's a lot of rules and syntax to learn. It's definitely not a must-have language feature.</p>
<p>Now back to the problem at hand.</p>
<p>Perhaps we should make it actually work?</p>
<pre><code class="javascript">
function toggle(shouldShow) {
  $collapseHandle.next().toggle( !shouldShow );
  $el.toggleClass( 'collapsed', !shouldShow );
}

toggle(true);
</code></pre>
<p>So we first select the content area which we know to be the element that follows our $collapseHandler, and use <a href="http://api.jquery.com/toggle/"><code>$.fn.toggle</code></a> to hide or show it. And then we <a href="http://api.jquery.com/toggleClass/"><code>$.fn.toggleClass</code></a> to mark the element collapsed or not. Go ahead, try this out, change the <code>toggle(true)</code> below to <code>toggle(false)</code>.</p>
<p><a class="jsbin-embed" href="http://jsbin.com/weniqu/29/embed?js,output">Basic functionality</a></p>
<h3>Closure scoping</h3>
<p>I think this would have been confusing only three years ago but I feel like the concept of lambdas and closures is by now natural enough that most people aren't questioning why $collapseHandle and <code>$el</code> are available here. One thing that's nice about javascript functions, is they're dirt simple. Forget what you know about java or c# scoping, just scan up the levels of indentation - exactly what you would think should be available, is.</p>
<p>This might seem limiting - without private, protected, and internal modifiers it would seem we're pretty limited in our attempts at data hiding. As we will see, this is not true and this simple concept can yield largely the same results.</p>
<h3>Hoisting</h3>
<p>I took the opportunity for some cleanup. Javascript has this interesting concept called <a href="http://elegantcode.com/2010/12/24/basic-javascript-part-5-hoisting/">hoisting</a>. It can be dangerous but it has some interesting uses as well. It works something like this - the only thing that limits a variable's scope in javascript is being inside of a function; not for loops; not declaration order. This is implemented as follows.</p>
<p>When the javascript interpreter encounters a function it makes two passes. It first looks for any variable and function declarations in the immediate body and declares them. This is why can refer to variables in the same function before they are var'ed (even though the value might be undefined); </p>
<pre><code class="javscript">
console.log(foo); //error
(function(){
	console.log(foo); //undefined
	var foo = 5;
	console.log(foo); //5
})()
</code></pre>
<p>this can cause subtle bugs if you reuse a variable or function name in the same function, but it can also be used wisely. Here's the thing - function declarations (as opposed to assignments), can't be automatically split from their variable. So they are both declared <strong>and defined</strong> at the function top. This means that function declarations can appear <strong>anywhere</strong> within a function body and be used everywhere else, more to the point, it means that - much like in class-based languages, we can create many private helper methods am move them away from the code governing what the function actually does. </p>
<p>Since the details of what <code>toggle</code> does are far less important than what we're actually doing with it, I moved that code toward the bottom of my function. The specifics of how the html structure is imposed are similarly secondary to the fact that it happens, these also go in their own private function and are bumped to the bottom.</p>
<p>Overall this is the strucutre I recommend for any function:</p>
<ol>
<li>var declarations, usually no more at one line each (create a private function if needed)</li>
<li>followed by thing the function actually does - trying to boil it down to the bare workflow mechanics</li>
<li>followed by as many private functions as your heart desires. </li>
</ol>
<p>The advantage is that tihs makes it very clear what any dependencies are (they are picked out toward the top), and <em>very</em> clear what the actual workflow is. And that's what I'm usually after when I read code, not the details of how you did something, but the gist of what it is that you are doing. If I want to dig into specifics I will do so only after understanding the context.</p>
<h2>Make it Work Better</h2>
<p>So I suppose we should make the darn thing actually react to click events huh? Well that can be as simple as adding</p>
<pre><code class="javascript">
  $collapseHandle.on('click', function(){
    toggle(...uhhh...what should go here?)
  })
</code></pre>
<p>hmm...seems like we need to maintain state somewhere. Lots of options here - we could test for the <code>.collapsed</code> class, or store it in the element's data. Or just create a simple variable tracking it! Closure rules to the rescue, we create an <code>isOpen</code> variable inside of our <code>makeCollapsible</code> function and voila.</p>
<p><a class="jsbin-embed" href="http://jsbin.com/weniqu/30/embed?js,output">Clicking works</a></p>
<p>We have the basics of a reusable clickable collapser.</p>
<h2>Adding Optional Parameters</h2>
<p>Not very customizable though, is it? How about we add an option to set the initial state to collapsed.</p>
<pre><code class="javascript">
  $('.should-collapse').toArray().map(function(el, index){ 
    makeCollapsible(el, {
      collapsed: index > 0
    }) 
  })
</code></pre>
<p>So every midget after the first one should be collapsed at initialization.</p>
<p><aside></p>
<h3>Json Object Notation</h3>
<p>is really cool here. What we want is named parameters. What we have is a json object. Which, minus the braces - looks exactly like named parameters. The fact that these objects are so lightweight works strongly in our favor as it is fairly easy to create and use these for an optional parameters object.
</aside></p>
<p>Speaking of which, let's take an options object as input</p>
<pre><code class="javascript">
  function makeCollapsible(el, options) {
    var $el = $(el).addClass('collapsible');
    var $collapseHandle = createStructure();
    var isOpen = !options.collapsed;
    ...
</code></pre>
<p>This will work great even when calling <code>makeCollapsed(el, {})</code> since in that case <code>collapsed</code> is undefined which the <code>!</code> operator converts to <code>false</code>. </p>
<p>Thanks to</p>
<p><aside></p>
<h3>Boolean Coercion</h3>
<p>We do however have a problem when going back to our old usage <code>makeCollapsed(el)</code> throws an error since in this case <code>options</code> itself doesn't exist for us to attempt to draw the <code>collapsed</code> property from.</p>
<p>There is a bunch of ways to set parameter defaults and here is my favorite one.</p>
<pre><code class="javascript">
  function makeCollapsible(el, options) {
    options || (options = {});
    ...
</code></pre>
<p>So, if options coerces to true (eg it is an object), continue; otherwise assign <code>{}</code> to options.</p>
<p>Yes, it doesn't handle a bunch of edge case scenarios quite properly, and an api released to the public I might be more stringent, but its simple and very visually distinctive. Within the internals of my code, where I can reasonably control my inputs, this works fine.
</aside></p>
<p>Of course this opens up a whole bunch of intriguing opportunities.</p>
<p>For example, what if the user wanted to provide a <strong>custom</strong> way for our area to appear or disappear? Something like</p>
<pre><code class="javascript">
  $('.should-collapse').toArray().map(function(el, index){ 
    makeCollapsible(el, {
      collapsed: index > 0,
      toggleArea: function($area, shouldOpen) {
        if(shouldOpen)
          $area.fadeIn();
        else
          $area.fadeOut();
      }
    }) 
  })
</code></pre>
<p>Well we could do this by checking explicitly</p>
<pre><code class="javascript">
  function makeCollapsible(el, options) {
    options || (options = {});
    options.toggleArea || (options.toggleArea = defaultToggleArea)
    ...
    function toggle(shouldShow) {
      options.toggleArea($collapseHandle.next(), shouldShow);
      $el.toggleClass( 'collapsed', !shouldShow );
      isOpen = shouldShow
    }
    ...
  }
  function defaultToggleArea($area, shouldShow) {
      $area.toggle( shouldShow );    
  }
</code></pre>
<p>and while that's ok, options is starting to get messy. Let's clean that up.</p>
<h2>Better Optional Parameters</h2>
<pre><code class="javascript">
(function(){
  var defaultOptions = {
    collapsed: false,
    toggleArea: defaultToggleArea
  };

  function makeCollapsible(el, op) {
    var options = $.extend({}, defaultOptions, op);
    ...
    toggle(isOpen);
    
    /////////////////////////    
    function toggle(shouldShow) {
      options.toggleArea($collapseHandle.next(), shouldShow);
      $el.toggleClass( 'collapsed', !shouldShow );
      isOpen = shouldShow
    }
    ...
  }
  function defaultToggleArea($area, shouldShow) {
      $area.toggle( shouldShow );    
  }
  
  window.makeCollapsible = makeCollapsible;
})()
</code></pre>
<p>A lot happened here, so lets take it step by step. Outside the <code>makeCollapsible</code> function but inside our module (so it is private) we created the <code>defaultOptions</code> variable with all of our defaults set. In order to do this we needed to move <code>defaultToggleArea</code> to the parent closure, but as it was not using any variables except those passed to it, this is not a problem.</p>
<p>Next we have that wierd <code>$.extend</code> call. I love the <code>$.extend</code> function. In fact, everyone does. It's so awesome that every single library that I can think of implements a version of it. So what does this ubiquitously useful function do? </p>
<p>It merges objects.</p>
<p><aside></p>
<h3>Objects are Just Hashes</h3>
<p>It's likely that you've heard this before, but here it really starts to make sense. to merge <code>var foo = {a: 1, b: 2}</code> and <code>var bar = {a: 1, c: 3}</code> simply iterate through each property of <code>bar</code> and write its value to the same property name of <code>foo</code> resulting in <code>{a: 1, b: 2, c: 3}</code>.</p>
<p>This is all that <code>extend</code> does. Starts with the second parameter and merges it into the first, then it merges the third parameter into that, etc.</p>
<p>This ends up being insanely useful, for example, have you ever wondered how to share functions between various objects without using javascript's crazy &quot;class&quot; system (in quotes because it doesn' t work the way most people think it does and should be avoided). Simple, just place the reusable methods in an object, and extend any others</p>
<pre><code class="javascript">
var animalBehavior = {
  eat: function() {...}
  sleep: function() {...}
}
...
var cat = $.extend(catSpecificBehavior, animalBehavior);
var dog = $.extend(dogSpecificBehavior, animalBehavior);
</code></pre>
<p>Disadvantages over prototypes and the <code>new</code> keyword? It doesn't show up in stacktraces as an isntance of <code>animalBehavior</code> and it's slightly slow (but really its so slight, that you shouldn't care). Advantages - far fewer bugs and unexpected behaviors as very few people understand <a href="http://stackoverflow.com/a/3658673/5056">what the <code>new</code> keyword <em>actually</em> does</a>.</p>
<p><code>new</code> is wierd and anti-intuitive, and introduces a sizable host of new concepts to keep track of. <code>extend</code> is dirt simple.
</aside>
<aside></p>
<h3>Dynamic Function Signatures</h3>
<p>As a matter of fact <code>extend</code> is so easy let's take a moment and implement our own naive version now. </p>
<pre><code class="javascript">
function extend(obj) {
  for(var i=1; i < arguments.length; i+=1) //iterate through all but the first (obj) argument
    for(var key in arguments[i])
      obj[key] = first[key];    //just copy all its properties
  return obj;
}
</code></pre>
<p>Isn't that awesome? And thanks to dynamic funciton signatures we can call it with one, two, three, or any number of parameters, it will just work!
</aside></p>
<p>And while we're at it, let's kick this party up another notch</p>
<p><a class="jsbin-embed" href="http://jsbin.com/weniqu/34/embed?js,output">defaultOptions object that is locally or globaly configurable</a></p>
<p>Here we've modified the above to add <code>defaultOptions</code> directly to the <code>makeCollapsible</code> function. I think most people are aware that its possible to add properties to functions but there is usually little reason to do it. In this case we decided that people might want to set defaults site-wide to achieve a consistent look and feel. We would therefore have to export <code>defaultOptions</code>. While we could create another global variable, in this case it feels natural to group both the function and its defaults together using the function as a sort of namespace.</p>
<p>This allows our widget's users to easily find and modify defaults.</p>
<p>And while we're at it, since we're now embracing the objects-are-just-hashes philosophy we can take the time and remove some duplciation from our fadein/out custom function. Since the only thing that is different is the name of the property we're invoking, we can select it in a one-liner <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator">with a ternary if</a>.</p>
<p>So what's left? Our collapse/expand all I supose.</p>
<h2>Exposing public functionality</h2>
<p>Something like this would be nice</p>
<pre><code class="javascript">
$(function(){
  makeCollapsible.defaultOptions.toggleArea = toggleAreaByFading
  var collapsers = $('.should-collapse').toArray().map(makeElementACollapser);

  $('.collapse-all').on('click', function(){
    collapsers.map(function(c){ c.collapse() });
  });
  $('.expand-all').on('click', function(){
    collapsers.map(function(c){ c.expand() });
  });
  
  
  function makeElementACollapser(el, index){ 
    return makeCollapsible(el, {
      collapsed: index > 0
    }) 
  }
  function toggleAreaByFading($area, shouldShow) {
    $area[shouldShow ? 'fadeIn' : 'fadeOut']()
  }
})
</code></pre>
<p>Well there you have it folks. We now need to have makeCollapsers return an object with methods. Surely this is a job for classes, right? Or not. Turns out that we can just return from <code>makeCollapsible</code> an object...with some methods...</p>
<pre><code class="javascript">
  $collapseHandle.on('click', function(){ toggle(!isOpen) })
  toggle(isOpen);
  
  return {
    collapse: function() { toggle(false) },
    expand: function() { toggle(true) }
  }
</code></pre>
<p>Almost disappointing how easy it is, ain't it? And yet I've seen many people struggle with how to achieve this for long minutes during interviews. </p>
<p>It's the classical inheritance knowledge getting in the way, making you think there's somethign you're missing. Yet no, using simple closures and lightweight objects, we have in effect mimicked a  constructor (the <code>makeCollapsible</code> method itself), private methods (<code>toggle</code>, <code>createStructure</code>), and public methods (<code>collapse</code>, <code>expand</code>). All without having to bring in concepts like <em>classes</em>, <em>instances</em>, or <em>access modifiers</em>.</p>
<p>Well since that was so easy let's go one step further and clean up the remaining code</p>
<h2>Final Cleanup</h2>
<p><a class="jsbin-embed" href="http://jsbin.com/weniqu/34/embed?js,output">Final Cleanup and Working Demo</a></p>
<p>Notice that I changed <code>function() { toggle(true) }</code> to <code>toggle.bind(null, true)</code> using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">Function.prototype.bind</a> to create a new function, with that parameter curried to true. It's a bit of a judgement call whether this is simpler or not, but I tend to like it.</p>
<p>More interesting is how we cleared up the redundant code that would iterate the collapsers to call expand or contract</p>
<pre><code class="javascript">
  $('.collapse-all').on('click', invokeOnAll(collapsers, 'collapse'));
  $('.expand-all').on('click', invokeOnAll(collapsers, 'expand'));
  
  function invokeOnAll(objects, methodName) { return function invokeOnAll() {
    return objects.map(function(x) { return x[methodName]() });
  }}  
</code></pre>
<p>A function that returns a function! You can learn more about this technique in Reginald Braithwaite's <a href="https://leanpub.com/javascript-allonge/read">Javascript Allong√©</a> and I think it cleans up this nicely. You might note that I named the returned function <code>invokeOnAll</code> as well. This is a tiny bit of defensive coding that doesn't actually do anything. Instead it ensures that the function has a name, so that when viewing debugging stack traces I see the name rather than <code>&amp;lt;anonymous function&amp;gt;</code>. It's nice.</p>
<p>So there we have it, the basics of achieving a collapsible area widget. You can easily imagine adding features to it. The ability to specify how you want the handle built so you can collapse to a heading, the ability to detect when the collapsing animation has finished (if one was used). The ability to name animations (eg <code>toggleArea: 'slide'</code>), and of course making it a jquery widget (though I would very much recommend here going a step further and using a <a href="http://learn.jquery.com/plugins/stateful-plugins-with-widget-factory/">jquery ui widget factory</a> which will take care of much of this for you).</p>
<p>All these things are achievable and made quite simple with the basic techniques outlined above. This is <strong>really</strong> javascript the good parts - the ability to eschew more complex concepts, and still build simple, flexible, and awesome things.</p>
<p><script src="http://static.jsbin.com/js/embed.js" async defer></script></p>

					<br />
					<a href="/2014/08/02/be-the-javascriptiest.html#disqus_thread">Comments</a>
				
			</div>
		</li>
    
		<li>
			<div class="idea">
				
					<h2><a class="postlink" href="/2014/04/29/on-this-and-new.html">On this and new</a></h2>
					<div class="postdate">29      April, 2014
						<ul>
						
						</ul>
					</div>
					<p>This is the pattern that a lot things recommend</p>
<pre><code class="javascript">
    function Person(firstName, lastName) {
      this.firstName = firstName;
      this.lastName = lastName;
      this.name = function() { return this.firstName + " " + this.lastName;}
    	this.printName = function() { console.log("my name is", this.name())}
    }
    var george = new Person("George", "Mauer");
</code></pre>
<p>What do you think that <code>new</code> does? It's not what you think. This is what <code>new</code> actually does</p>
<pre><code class="javascript">
    var fn = new Function();
    fn.__proto__ = Person; //chrome only - each browser has a different syntax for this step
    var res = Person.call(fn, firstName, lastName);
    return (res === undefined) ? fn : res;
</code></pre>
<p>Huh? But that's insane.....exactly.</p>
<p>What about <code>this</code>? How can that be confusing.</p>
<p>The problem is that despite what you think <code>this</code> doesn't reference scope. It is really just a parameter like any other. This becomes a lot more clear if you realize that</p>
<p><pre><code class="javascript">
    myFunc(1,2,3); 
<pre><code class="javascript"></p>
<p>is really just a facade for how javascript <strong>really</strong> invokes methods</p>
<p><pre><code class="javascript">
    myFunc.call(whateverThisIs, 1, 2, 3);
<pre><code class="javascript"></p>
<p>So all that <code>this</code> is, is just the first parameter passed into <code>.call()</code>. That's it - no magic, no language-support, it's just a parameter.</p>
<p>Worse, if you use the simpler syntax, javascript will pick what the value of that parameter should be at runtime. The rules aren't terribly complex but they're often not what you want. As an example:</p>
<pre><code class="javascript">
    george.printName(); //equivalent to george.prototype.printName.call(george)
    var printName = george.printName();
    printName();        //equivalent to george.prototype.printName.call(window);
</code></pre>
<p>And it gets wierder if you consider strict mode.</p>
<p>A lot of libraries <strong>also</strong> take guesses at what <code>this</code> should be.</p>
<pre><code class="javascript">
    $('button').click(george.printName); //this won't work because "this" is the button element and doesn't have name()
</code></pre>
<p><code>this</code> is therefore a parameter like any other and by using it you're trusting people to always pass in the correct value. And other people know less about <code>this</code> than you do!</p>
<p>so you <strong>could</strong> always use the <code>fn.call()</code> syntax. Or you could</p>
<h1>Not Use this or new</h1>
<p>The same code but without these keywords:</p>
<pre><code class="javascript">
    function createPerson(firstName, lastName) {
    	var _p = {
    		 firstName: firstName
    		,lastName:  lastName
    		,name:      function() { return _p.firstName + " " + _p.lastName}
    		,printName: function() { console.log("My name is", _p.name())}
    	};
    	return _p;  // I like an underscore prefix to indicate "this is what I'm buiding here"
    }
    
    var betterGeorge = createPerson("George", "Mauer");
</code></pre>
<p>And bam! No more wierd implicit parameters, callbacks and everything else works great forever!</p>
<h1>To Be Fair</h1>
<p>Sometimes you can't get away from it. If you're in a jQuery callback for example you might have to use <code>this</code> because that's how the framework works. But please, <strong>please</strong> don't write your own code to use it.</p>
<p>Also, there ARE a few benefits to the <code>new</code>/<code>this</code> thing.</p>
<ul>
<li>In some cases referencing <code>this</code> is slightly faster than referencing a variable in a parent scope. This difference is very slight and basically matters only if you're writting the next underscore or jQuery. Your project doesn't need it. Seriously Mario, your bottleneck is in another castle.</li>
<li>If you need to <a href="http://caniuse.com/#search=object.create">support a browser without <code>Object.create</code></a> there is no other way to wire up prototype inheritence cross-browser. This is another thing that unless you're building an extensible framework you probably don't need. If you need to share properties or methods every library has a version of the <a href="http://api.jquery.com/jQuery.extend/">extend helper</a> that will work for this.</li>
<li>Finally, there's the fact that when logged to a console, things with a prototype look <strong>slightly</strong> nicer and are labeled as their prototype rather than as &quot;Object&quot;. This is valid but a tiny, tiny issue.</li>
</ul>
<p>As a whole these benefits certainly don't excuse introducing two whole new concepts into your code, especially concepts that are as confusing and poorly understood as <code>new</code> and <code>this</code>.</p>
<p>I think it is probably only fair to amend that I'm usually opposed to javascript class systems in general. They require the use of <code>new</code> (though not necessarily of <code>this</code> - I'll write up how later)
and between function composition and the extend pattern are generally not necessary for either organizing or building performant code in 90% of cases.</p>

					
					<a href="/2014/04/29/on-this-and-new.html#disqus_thread">Comments</a>
				
			</div>
		</li>
    
</ul>
<h3>OLDER</h3>
<ul class="postArchive">

</ul>
<p><script type="text/javascript">
//&lt;![CDATA[
(function() {
    var links = document.getElementsByTagName('a');
    var query = '?';
    for(var i = 0; i &lt; links.length; i++) {
    if(links[i].href.indexOf('#disqus_thread') &gt;= 0) {
        query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&amp;';
    }
    }
    document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/DISQUS_NAME/get_num_replies.js' + query + '">&lt;/' + 'script&gt;');
})();
//]]&gt;
</script></p>

			</div>

		</div>
	</body>
</html>